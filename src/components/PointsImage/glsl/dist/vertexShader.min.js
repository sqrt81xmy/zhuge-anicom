"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var vertexShader="#ifdef GL_ES\nprecision mediump float;\n#endif\n \n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n// uniform mat4 modelMatrix;\nuniform vec2 uFrequency;  \nuniform float uScroll;\nuniform float positionDeltaX;\nuniform float uTime;\nuniform sampler2D uIntensityTexture;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nattribute float aRandom;\nattribute float aIRandom;\nvarying float vRandom;\n\nvarying vec2 vUv; \nvarying vec3 vPosition;\nvarying vec3 vColor;\n\n\nuniform float scrollUpFlag;\nuniform float uScrollNoSin;\nuniform float uScrollSin;\n\nuniform float uMaxPositionX;\n\n// void dealScroll(){\n//     if(scrollUpFlag == 1){\n//         if( uScrollSin >  deltaScroll &&\n//             recTime <  timeThrehold\n//             ){ \n//             uScrollSin -= deltaTime * frequency;\n//             // console.log(this.recTime,this.uniforms.get('uScrollSin').value,deltaTime ) \n//         }\n//         else if(\n//             uScrollSin <=  deltaScroll && \n//             recTime < timeThrehold\n//             ){ \n//             recTime += deltaTime * frequency;\n//         } \n//         //         //这里的deltaTime相当于一个常量\n//         // }  //让角度收回的时候y位置做匀减速运动\n//         else if(\n//             recTime >= timeThrehold && \n//             frequency > 0.0\n//             ){  \n\n//                 // this.uniforms.get('uScrollSin').value = 0.0;\n//                 //这里需要做一个减加速度运动\n//                 //x = （0.1 * freq * deltaTime)*t -> x' = (0.1 * freq * deltaTime)\n//                 //减加速度运动 v -= a * t -> 0.1*(freq-a)*deltaTime\n//                 //这里让a和freq是一个数量级 \n//                 // delta(x) = 0.1(freq-a)*deltaTime\n//                 if(uScrollSin+deltaTime * fixFrequency <= 0.0)\n//                     uScrollSin += deltaTime * fixFrequency;\n//                 frequency -= accelerator; //速度匀减速\n//             uScrollNoSin -= frequency * 0.09 * deltaTime; //位移加\n//         }\n//         else if(\n//             recTime >= timeThrehold && \n//             frequency <= 0.0)\n//         {\n//             console.log(5) \n//             recTime = 0;\n//             scrollUpFlag = 0;\n//             lastNoSin = uScrollNoSin;\n//             this.frequency = 7.0;\n//         }\n//     }\n    \n// }\n\n\nfloat modRange(float x, float minVal, float maxVal) {\n    float rangeSize = maxVal - minVal; // 计算范围大小\n    // 将 x 移动到范围 [0, rangeSize]\n    float adjustedX = x - minVal;\n    \n    // 取模运算处理\n    adjustedX = mod(adjustedX, rangeSize);\n    \n    // 返回到原始范围\n    return adjustedX + minVal;\n}\n\nvoid main(){ \n  \n    // float evaluationZ = cos((newPosition.x)*3.1415)*uScroll;\n    // newPosition.z = evaluationZ;\n    // float evaluationX = abs(newPosition.x)*(newPosition.x)*3.1415*uScroll*0.1;\n    // newPosition.x -= evaluationX;\n\n    // float theta = abs(1.0-position.x) * uScroll * 0.5;\n    // newPosition.z -= abs(position.x)*uScroll*0.5;\n    // // newPosition.x *= ( cos(theta)*0.5);\n    // newPosition.y -= position.x*uScroll*0.2; \n    // newPosition.x += uScroll * 0.1;\n    // newPosition.z += (newPosition.x*newPosition.x - newPosition.y*newPosition.y)*uScroll*2.0;\n    // float factor = newPosition.x / abs(newPosition.x);\n    // newPosition.y *= (1.0-(uScroll*sin(newPosition.x)*0.5));\n   \n   // newPosition.y += -(cos(2.7 * newPosition.x) * uScroll *0.4);\n    //newPosition.y += uScroll;\n    \n    // float xRandom = fract(sin(position.x * 1000.0 + uTime) * 43758.5453); // 改良随机数生成\n    float interactiveTense = texture2D(uIntensityTexture,uv).r;\n    interactiveTense = smoothstep(0.1,0.3,interactiveTense);\n    vec3 AddVec = vec3(0.2*sin(aRandom),0.2*cos(aRandom),0)*interactiveTense*0.4*aIRandom;\n    // float deltaX = sin(x)/20.0;\n\n \n\n    vec4 modelPosition = modelMatrix * vec4(position+AddVec,1.0);  \n    //把这里放开\n    float deltaySin =  ((cos((modelPosition.x/uMaxPositionX) * 3.2) * 0.1)*uScrollSin);\n    modelPosition.x += sin(modelPosition.y*6.4+uTime) * uTime / 25.0;\n    modelPosition.y += uScrollNoSin;\n    modelPosition.z += deltaySin;\n\n    modelPosition.y = modRange(modelPosition.y, -1.2, 1.2);\n\n   \n    //把上面放开\n    // vec4 newPosition = modelPosition; \n\n    // modelPosition.x += deltaX;\n    // modelPosition.y += deltaX;\n   \n    // newPosition.x += positionDeltaX;\n    // newPosition.z += (cos(0.1 * newPosition.x) *0.4);\n    // modelPosition.x += sin(modelPosition.y * uFrequency.y + uTime) * 0.1;\n    // modelPosition.y += evaluation;\n   \n    // float elevation = sin(modelPosition.x*5.0  - uTime*0.5) * 0.1;\n    // modelPosition.z += elevation;\n    \n    vec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectedPosition = projectionMatrix *viewPosition;\n    gl_Position = projectedPosition;\n\n    // float tense = texture(uTexture,uv).r;\n    gl_PointSize = 0.006  * uResolution.y;\n    gl_PointSize *= (1.0 / (- viewPosition.z));\n    // gl_PointSize = 3.0;\n    // float intensity = texture(uDisplacementT/exture,uv).r; \n    vUv = uv; \n    vRandom = aRandom;\n    vColor = texture(uTexture,uv).rgb;\n}",_default=vertexShader;exports.default=_default;
//# sourceMappingURL=vertexShader.min.js.map

{"version":3,"sources":["vertexShader.js"],"names":["vertexShader"],"mappings":"2FAAA,IAAMA,aACN,49JAwJeA","file":"vertexShader.min.js","sourcesContent":["const vertexShader =   \r\n'#ifdef GL_ES\\n'+\r\n'precision mediump float;\\n' +\r\n'#endif\\n' + /*glsl*/` \r\n// uniform mat4 projectionMatrix;\r\n// uniform mat4 viewMatrix;\r\n// uniform mat4 modelMatrix;\r\nuniform vec2 uFrequency;  \r\nuniform float uScroll;\r\nuniform float positionDeltaX;\r\nuniform float uTime;\r\nuniform sampler2D uIntensityTexture;\r\nuniform sampler2D uTexture;\r\nuniform vec2 uResolution;\r\nattribute float aRandom;\r\nattribute float aIRandom;\r\nvarying float vRandom;\r\n\r\nvarying vec2 vUv; \r\nvarying vec3 vPosition;\r\nvarying vec3 vColor;\r\n\r\n\r\nuniform float scrollUpFlag;\r\nuniform float uScrollNoSin;\r\nuniform float uScrollSin;\r\n\r\nuniform float uMaxPositionX;\r\n\r\n// void dealScroll(){\r\n//     if(scrollUpFlag == 1){\r\n//         if( uScrollSin >  deltaScroll &&\r\n//             recTime <  timeThrehold\r\n//             ){ \r\n//             uScrollSin -= deltaTime * frequency;\r\n//             // console.log(this.recTime,this.uniforms.get('uScrollSin').value,deltaTime ) \r\n//         }\r\n//         else if(\r\n//             uScrollSin <=  deltaScroll && \r\n//             recTime < timeThrehold\r\n//             ){ \r\n//             recTime += deltaTime * frequency;\r\n//         } \r\n//         //         //这里的deltaTime相当于一个常量\r\n//         // }  //让角度收回的时候y位置做匀减速运动\r\n//         else if(\r\n//             recTime >= timeThrehold && \r\n//             frequency > 0.0\r\n//             ){  \r\n\r\n//                 // this.uniforms.get('uScrollSin').value = 0.0;\r\n//                 //这里需要做一个减加速度运动\r\n//                 //x = （0.1 * freq * deltaTime)*t -> x' = (0.1 * freq * deltaTime)\r\n//                 //减加速度运动 v -= a * t -> 0.1*(freq-a)*deltaTime\r\n//                 //这里让a和freq是一个数量级 \r\n//                 // delta(x) = 0.1(freq-a)*deltaTime\r\n//                 if(uScrollSin+deltaTime * fixFrequency <= 0.0)\r\n//                     uScrollSin += deltaTime * fixFrequency;\r\n//                 frequency -= accelerator; //速度匀减速\r\n//             uScrollNoSin -= frequency * 0.09 * deltaTime; //位移加\r\n//         }\r\n//         else if(\r\n//             recTime >= timeThrehold && \r\n//             frequency <= 0.0)\r\n//         {\r\n//             console.log(5) \r\n//             recTime = 0;\r\n//             scrollUpFlag = 0;\r\n//             lastNoSin = uScrollNoSin;\r\n//             this.frequency = 7.0;\r\n//         }\r\n//     }\r\n    \r\n// }\r\n\r\n\r\nfloat modRange(float x, float minVal, float maxVal) {\r\n    float rangeSize = maxVal - minVal; // 计算范围大小\r\n    // 将 x 移动到范围 [0, rangeSize]\r\n    float adjustedX = x - minVal;\r\n    \r\n    // 取模运算处理\r\n    adjustedX = mod(adjustedX, rangeSize);\r\n    \r\n    // 返回到原始范围\r\n    return adjustedX + minVal;\r\n}\r\n\r\nvoid main(){ \r\n  \r\n    // float evaluationZ = cos((newPosition.x)*3.1415)*uScroll;\r\n    // newPosition.z = evaluationZ;\r\n    // float evaluationX = abs(newPosition.x)*(newPosition.x)*3.1415*uScroll*0.1;\r\n    // newPosition.x -= evaluationX;\r\n\r\n    // float theta = abs(1.0-position.x) * uScroll * 0.5;\r\n    // newPosition.z -= abs(position.x)*uScroll*0.5;\r\n    // // newPosition.x *= ( cos(theta)*0.5);\r\n    // newPosition.y -= position.x*uScroll*0.2; \r\n    // newPosition.x += uScroll * 0.1;\r\n    // newPosition.z += (newPosition.x*newPosition.x - newPosition.y*newPosition.y)*uScroll*2.0;\r\n    // float factor = newPosition.x / abs(newPosition.x);\r\n    // newPosition.y *= (1.0-(uScroll*sin(newPosition.x)*0.5));\r\n   \r\n   // newPosition.y += -(cos(2.7 * newPosition.x) * uScroll *0.4);\r\n    //newPosition.y += uScroll;\r\n    \r\n    // float xRandom = fract(sin(position.x * 1000.0 + uTime) * 43758.5453); // 改良随机数生成\r\n    float interactiveTense = texture2D(uIntensityTexture,uv).r;\r\n    interactiveTense = smoothstep(0.1,0.3,interactiveTense);\r\n    vec3 AddVec = vec3(0.2*sin(aRandom),0.2*cos(aRandom),0)*interactiveTense*0.4*aIRandom;\r\n    // float deltaX = sin(x)/20.0;\r\n\r\n \r\n\r\n    vec4 modelPosition = modelMatrix * vec4(position+AddVec,1.0);  \r\n    //把这里放开\r\n    float deltaySin =  ((cos((modelPosition.x/uMaxPositionX) * 3.2) * 0.1)*uScrollSin);\r\n    modelPosition.x += sin(modelPosition.y*6.4+uTime) * uTime / 25.0;\r\n    modelPosition.y += uScrollNoSin;\r\n    modelPosition.z += deltaySin;\r\n\r\n    modelPosition.y = modRange(modelPosition.y, -1.2, 1.2);\r\n\r\n   \r\n    //把上面放开\r\n    // vec4 newPosition = modelPosition; \r\n\r\n    // modelPosition.x += deltaX;\r\n    // modelPosition.y += deltaX;\r\n   \r\n    // newPosition.x += positionDeltaX;\r\n    // newPosition.z += (cos(0.1 * newPosition.x) *0.4);\r\n    // modelPosition.x += sin(modelPosition.y * uFrequency.y + uTime) * 0.1;\r\n    // modelPosition.y += evaluation;\r\n   \r\n    // float elevation = sin(modelPosition.x*5.0  - uTime*0.5) * 0.1;\r\n    // modelPosition.z += elevation;\r\n    \r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix *viewPosition;\r\n    gl_Position = projectedPosition;\r\n\r\n    // float tense = texture(uTexture,uv).r;\r\n    gl_PointSize = 0.006  * uResolution.y;\r\n    gl_PointSize *= (1.0 / (- viewPosition.z));\r\n    // gl_PointSize = 3.0;\r\n    // float intensity = texture(uDisplacementT/exture,uv).r; \r\n    vUv = uv; \r\n    vRandom = aRandom;\r\n    vColor = texture(uTexture,uv).rgb;\r\n}`\r\n\r\nexport default vertexShader;"]}